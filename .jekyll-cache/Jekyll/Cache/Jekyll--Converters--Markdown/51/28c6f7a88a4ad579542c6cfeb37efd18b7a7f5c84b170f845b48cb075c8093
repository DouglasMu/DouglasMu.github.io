I"<ul id="markdown-toc">
  <li><a href="#冒泡排序" id="markdown-toc-冒泡排序">冒泡排序</a>    <ul>
      <li><a href="#1-算法步骤" id="markdown-toc-1-算法步骤">1. 算法步骤</a></li>
      <li><a href="#2-动图演示" id="markdown-toc-2-动图演示">2. 动图演示</a></li>
      <li><a href="#3-python-代码实现" id="markdown-toc-3-python-代码实现">3. Python 代码实现</a></li>
    </ul>
  </li>
</ul>

<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，
一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、
选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括：
<img src="https://i.loli.net/2020/10/20/CeIyAlaY3DMFGcH.png" alt="经典排序" /></p>

<p>关于时间复杂度：</p>

<ul>
  <li>
    <p>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</p>
  </li>
  <li>
    <p>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序。</p>
  </li>
  <li>
    <p>(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序。</p>
  </li>
  <li>
    <p>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</p>
  </li>
</ul>

<p>关于稳定性：</p>

<ul>
  <li>
    <p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>
  </li>
  <li>
    <p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
  </li>
</ul>

<p>名词解释：</p>

<ul>
  <li>
    <p>n：数据规模</p>
  </li>
  <li>
    <p>k：“桶”的个数</p>
  </li>
  <li>
    <p>In-place：占用常数内存，不占用额外内存</p>
  </li>
  <li>
    <p>Out-place：占用额外内存</p>
  </li>
  <li>
    <p>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p>
  </li>
</ul>

<h4 id="冒泡排序">冒泡排序</h4>
<p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，
一次比较两个元素，如果他们的顺序错误就把他们交换过来。
走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>

<p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，
每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，
就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。
但这种改进对于提升性能来说并没有什么太大作用。</p>

<h5 id="1-算法步骤">1. 算法步骤</h5>

<ul>
  <li>
    <p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
  </li>
  <li>
    <p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
  </li>
  <li>
    <p>针对所有的元素重复以上的步骤，除了最后一个。</p>
  </li>
  <li>
    <p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
    <h5 id="2-动图演示">2. 动图演示</h5>
    <p><img src="https://mmbiz.qpic.cn/mmbiz_gif/MQ4FoG1HmnIounJsWSXZfDLJt1kG3t5VL4nZJtTUPSe7voA0tTiaHt9ZDshJic0SM9bapHg31OHOGjQiclbQjl1QA/640?wx_fmt=gif" alt="冒泡排序动图" /></p>
  </li>
</ul>

<h5 id="3-python-代码实现">3. Python 代码实现</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arr</span>
</code></pre></div></div>
:ET